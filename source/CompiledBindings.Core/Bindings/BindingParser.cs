namespace CompiledBindings;

public static class BindingParser
{
	public static Bind Parse(XamlObjectProperty prop, TypeInfo sourceType, TypeInfo targetType, string dataRootName, BindingMode defaultBindMode, XamlDomParser xamlDomParser, HashSet<string> includeNamespaces, bool throwIfWithoutDataType, ref int localVarIndex)
	{
		var xBind = prop.XamlNode.Children[0];
		var str = xBind.Value?.TrimEnd();
		if (string.IsNullOrWhiteSpace(str))
		{
			throw new ParseException(Res.MissingExpression);
		}

		var namespaces = xamlDomParser.GetNamespaces(prop.XamlNode).ToList();

		Expression? path = null;
		Expression? bindBack = null;
		Expression? converter = null;
		Expression? converterParameter = null;
		Expression? fallbackValue = null;
		Expression? targetNullValue = null;
		TypeInfo? dataType = null;
		string? stringFormat = null;
		bool dataTypeSet = false;
		BindingMode? mode = null;
		bool isItemsSource = false;
		List<EventInfo> targetChangedEvents = [];

		// Try to find DataType property in the binding before parsing any expression
		// TODO: how to match optional comma and not include it in the group?
		var match = Regex.Match(str, @"^.*DataType\s*(?<!=)=(?!=)(.+)");
		if (match.Success)
		{
			var typeExpr = match.Groups[1].Value.Trim();
			var pos = typeExpr.IndexOf(',');
			if (pos != -1)
			{
				typeExpr = typeExpr.Substring(0, pos);
			}
			var type = xamlDomParser.FindType(typeExpr, (XAttribute)prop.XamlNode.Element);
			dataType = type == null ? null : type.ToNotNullable();
			dataTypeSet = true;

			sourceType = dataType ?? targetType;
		}
		else if (throwIfWithoutDataType)
		{
			throw new ParseException(Res.NoDataType);
		}

		int currentPos = 0, pos1 = 0;
		while (true)
		{
			if (pos1 == str!.Length)
			{
				break;
			}

			var str2 = str.Substring(pos1).TrimStart();
			if (str2.Length == 0)
			{
				break;
			}

			currentPos += str.Length - str2.Length;
			str = str2;

			string name;
			match = Regex.Match(str, @"^(\w+)\s*(?<!=)=(?!=)\s*(.+)\s*$");
			if (match.Success)
			{
				name = match.Groups[1].Value;

				if (name == "Path" && path != null)
				{
					throw new ParseException(Res.SyntaxError);
				}

				str = match.Groups[2].Value;
			}
			else if (path == null)
			{
				name = "Path";
			}
			else
			{
				throw new ParseException(Res.SyntaxError);
			}

			if (name is "Path" or "BindBack" or "Converter" or "ConverterParameter" or "FallbackValue" or "TargetNullValue")
			{
				Expression expr;
				if (name is "Converter" or "ConverterParameter" or "FallbackValue" or "TargetNullValue" &&
					Regex.Match(str, @"{StaticResource\s+(\w+)}") is var match2 && match2.Success)
				{
					var resourceName = match2.Groups[1].Value;
					var resourceType = name switch
					{
						"Converter" => xamlDomParser.ConverterType,
						"FallbackValue" or "TargetNullValue" => prop.MemberType,
						_ => TypeInfo.GetTypeThrow(typeof(object))
					};

					expr = new StaticResourceExpression(resourceName, resourceType);

					int pos2 = str.IndexOf(',');
					pos1 = pos2 == -1 ? (pos2 = str.Length) : pos2 + 1;
				}
				else
				{
					ICollection<string> includeNamespaces2;
					try
					{
						expr = ExpressionParser.Parse(sourceType, dataRootName, str, prop.MemberType, false, namespaces, out includeNamespaces2, out pos1, name == "BindBack");
					}
					catch (ParseException ex)
					{
						throw new ParseException(ex.Message, currentPos + ex.Position, ex.Length);
					}
					includeNamespaces.UnionWith(includeNamespaces2);
				}

				if (name == "Path")
				{
					path = expr;
				}
				else if (name == "BindBack")
				{
					bindBack = expr;
					mode ??= BindingMode.TwoWay;
				}
				else if (name == "FallbackValue")
				{
					fallbackValue = expr;
				}
				else if (name == "TargetNullValue")
				{
					targetNullValue = expr;
				}
				else if (name == "Converter")
				{
					converter = expr;
				}
				else
				{
					converterParameter = expr;
				}
			}
			else if (name is "StringFormat")
			{
				if (str.StartsWith("{}"))
				{
					str = str.Substring(2);
				}

				// Find end of string format. It can contain commas, escaped with \ symbol
				match = Regex.Match(str, @"^(.*?)(?<!\\),");
				if (match.Success)
				{
					stringFormat = match.Groups[1].Value;
					pos1 = stringFormat.Length + 1;
				}
				else
				{
					stringFormat = str;
					pos1 = stringFormat.Length;
				}
				stringFormat = stringFormat.Replace("\\,", ",");
			}
			else if (name is "Mode" or "UpdateSourceEventNames" or "DataType" or "IsItemsSource")
			{
				int pos2 = str.IndexOf(',');
				pos1 = pos2 == -1 ? (pos2 = str.Length) : pos2 + 1;

				var value = str.Substring(0, pos2).Trim();

				if (name == "Mode")
				{
					if (Enum.TryParse<BindingMode>(value, out var mode2))
					{
						mode = mode2;
					}
					else
					{
						var msg = $"Mode is invalid: {value}.";
						if (path == null)
						{
							msg += " Use 'eq' instead of '=' to compare 'Mode' in expression.";
						}
						throw new ParseException(msg, currentPos + match.Groups[2].Index);
					}
				}
				else if (name == "DataType")
				{
					// The DataType was processed above
				}
				else if (name == "IsItemsSource")
				{
					if (!bool.TryParse(value, out isItemsSource))
					{
						throw new ParseException($"Invalid boolean value: {value}", currentPos + match.Groups[2].Index);
					}
				}
				else
				{
					foreach (var eventName in value.Split('|').Select(_ => _.Trim()).Distinct())
					{
						var targetChangedEvent = prop.Object.Type.Events.FirstOrDefault(e => e.Definition.Name == eventName);
						if (targetChangedEvent == null)
						{
							throw new ParseException($"The type {prop.Object.Type.Reference.FullName} does not have event {value}.", currentPos + match.Groups[2].Index);
						}
						targetChangedEvents.Add(targetChangedEvent);
					}
					mode ??= BindingMode.TwoWay;
				}
			}
			else
			{
				throw new ParseException($"Property {name} is not valid for x:Bind", currentPos);
			}
		}

		if (path == null)
		{
			if (bindBack == null)
			{
				throw new ParseException("Missing Path or BindBack expression.");
			}
			if (mode == null)
			{
				mode = BindingMode.OneWayToSource;
			}
			else if (mode != BindingMode.OneWayToSource)
			{
				throw new ParseException("Missing expression.");
			}
		}

		if (mode is BindingMode.TwoWay or BindingMode.OneWayToSource &&
			(bindBack ?? path) is not (MemberExpression or CallExpression or ElementAccessExpression))
		{
			throw new ParseException("The expression must be settable for TwoWay or OneWayToSource bindings.");
		}

		if (isItemsSource && path == null)
		{
			throw new ParseException("IsItemsSource cannot be used for OneWayToSource bindings.");
		}

		Expression? bindExpression = path;
		Expression? asyncBindExpression = null;

		if (bindExpression != null)
		{
			Expression bindExpression2;

			var taskType = TypeInfo.GetTypeThrow(typeof(System.Threading.Tasks.Task));
			bool isTask = taskType.IsAssignableFrom(bindExpression.Type);
			if (isTask)
			{
				var taskResultType = bindExpression.Type.GetGenericArguments()![0];
				bindExpression2 = new VariableExpression(taskResultType, "result");
			}
			else
			{
				bindExpression2 = bindExpression;
			}

			if (converter != null)
			{
				var convertMethod = xamlDomParser.ConverterType!.Methods.First(m => m.Definition.Name == "Convert");
				bindExpression2 = new CallExpression(converter, convertMethod,
				[
					bindExpression2,
					new TypeofExpression(new TypeExpression(prop.MemberType)),
					converterParameter ?? Expression.NullExpression,
					Expression.NullExpression
				]);
				if (prop.MemberType.Reference.FullName != "System.Object")
				{
					bindExpression2 = new CastExpression(bindExpression2, prop.MemberType, false);
				}
			}

			if (targetNullValue != null)
			{
				bindExpression2 = new CoalesceExpression(bindExpression2, targetNullValue);
			}

			if (stringFormat != null)
			{
				var stringFormatSaved = stringFormat;
				stringFormat = Regex.Replace(stringFormat, @"(.*)(\{)(0)(?:(\:.+))?(\})(.*)", "$\"$1{{{0}$4}}$6\"");
				if (stringFormat == stringFormatSaved)
				{
					stringFormat = $"$\"{{{{{{0}}:{stringFormat}}}}}\"";
				}
				bindExpression2 = new InterpolatedStringExpression(stringFormat, new[] { bindExpression2 });
			}

			if (isTask)
			{
				asyncBindExpression = bindExpression2;
			}
			else
			{
				if (fallbackValue != null)
				{
					bindExpression2 = FallbackExpression.CreateFallbackExpression(bindExpression2, fallbackValue, ref localVarIndex);
				}
				bindExpression = bindExpression2;
			}
		}

		Expression? bindBackExpression = null;

		if (mode is BindingMode.TwoWay or BindingMode.OneWayToSource)
		{
			if (bindBack != null)
			{
				bindBackExpression = bindBack;
				if (!bindBackExpression.EnumerateTree().Any(e => e is ValueExpression))
				{
					if (bindBackExpression is MemberExpression me && me.Member is MethodInfo method)
					{
						if (prop.MemberType.Reference.FullName != "System.Delegate")
						{
							var targetType2 = method.Parameters.Last().ParameterType;
							Expression valueExpr = new ValueExpression(prop.MemberType);
							valueExpr = Expression.Convert(valueExpr, targetType2);
							bindBackExpression = new CallExpression(me.Expression, method, [valueExpr]);
						}
					}
					else
					{
						throw new ParseException("Invalid BindBack expression.");
					}
				}
			}
			else
			{
				var targetType2 = path!.Type;
				var valueExpr = new ValueExpression(prop.MemberType);
				bindBackExpression = valueExpr;

				if (converter != null)
				{
					var convertBackMethod = xamlDomParser.ConverterType!.Methods.First(m => m.Definition.Name == "ConvertBack");
					bindBackExpression = new CallExpression(converter, convertBackMethod,
					[
						bindBackExpression,
						new TypeofExpression(new TypeExpression(targetType2)),
						converterParameter ?? Expression.NullExpression,
						Expression.NullExpression
					]);
					if (path.Type.Reference.FullName != "System.Object")
					{
						bindBackExpression = new CastExpression(bindBackExpression, targetType2, false);
					}
				}
				else
				{
					bindBackExpression = Expression.Convert(bindBackExpression, path!.Type);
					if (bindBackExpression == valueExpr && !path.Type.IsAssignableFrom(bindBackExpression.Type))
					{
						var convertType = TypeInfo.GetTypeThrow(typeof(Convert));
						var convertMethod = convertType.Methods.First(m => m.Definition.Name == nameof(Convert.ChangeType));
						var convertTypeExpr = new TypeExpression(convertType);

						if (targetType2.Reference.IsValueNullable())
						{
							targetType2 = targetType2.GetGenericArguments()![0];
						}

						var convertExpression = new CastExpression(
							new CallExpression(
								convertTypeExpr,
								convertMethod,
								[
									valueExpr,
										new TypeofExpression(new TypeExpression(targetType2)),
										Expression.NullExpression
								]),
							targetType2);

						if (prop.MemberType.Reference.IsNullable() || prop.MemberType.Reference.FullName == "System.String")
						{
							var localVarName = "v" + localVarIndex++;
							var localVarExpr = new VariableExpression(prop.MemberType, localVarName);
							
							Expression? check;							
							if (prop.MemberType.Reference.FullName == "System.String")
							{
								//!string.IsNullOrEmpty(v)"
								var stringType = TypeInfo.GetTypeThrow(typeof(string));
								check = new UnaryExpression(
									new CallExpression(
										new TypeExpression(stringType),
										stringType.Methods.First(m => m.Definition.Name == nameof(string.IsNullOrEmpty)),
										[localVarExpr]),
									"!");
							}
							else
							{
								// Set to null to create v != null expression
								check = null;
							}
							
							var @default = sourceType.Reference.IsNullable() ? (Expression)Expression.NullExpression : Expression.DefaultExpression;
							
							bindBackExpression = new FallbackExpression(
								convertExpression,
								valueExpr,
								@default,
								localVarExpr,
								check);
						}
						else
						{
							bindBackExpression = convertExpression;
						}
					}
				}

				bindBackExpression = new AssignExpression(path!, bindBackExpression);
			}
		}

		return new Bind
		{
			SourceType = sourceType,
			Property = prop,
			DataType = dataType,
			DataTypeSet = dataTypeSet,
			Path = path,
			BindBack = bindBack,
			Converter = converter,
			ConverterParameter = converterParameter,
			FallbackValue = fallbackValue,
			Mode = mode ?? defaultBindMode,
			IsItemsSource = isItemsSource,
			UpdateSourceEvents = targetChangedEvents,
			BindExpression = bindExpression,
			AsyncBindExpression = asyncBindExpression,
			BindBackExpression = bindBackExpression,
		};
	}

	public static BindingsClass CreateBindingsClass(IList<Bind> binds, TypeInfo? targetType, TypeInfo dataType, TypeInfo? dependencyObjectType = null)
	{
		// Set unique indexes used as ids for all bindings in this binding scope
		for (int i = 0; i < binds.Count; i++)
		{
			binds[i].Index = i;
		}

		var iNotifyPropertyChangedType = TypeInfo.GetTypeThrow(typeof(INotifyPropertyChanged));
		var iNotifyCollectionChangedType = TypeInfo.GetTypeThrow(typeof(INotifyCollectionChanged));
		var taskType = TypeInfo.GetTypeThrow(typeof(System.Threading.Tasks.Task));

		// Go through all expressions in bindings and find notifiable properties, grouped by notifiable source
		var notifySources = GetNotifySources(binds, iNotifyPropertyChangedType, iNotifyCollectionChangedType, dependencyObjectType);

		// Set dependencies between notify sources
		foreach (var notifySource in notifySources.OrderByDescending(d => getSourceExpr(d.Expression).Key))
		{
			foreach (var notifyProp in notifySource.Properties)
			{
				var expr = notifyProp.Expression.Key;
				foreach (var notifySource2 in notifySources
					.Where(g => g != notifySource && getSourceExpr(g.Expression).EnumerateTree().Any(e => e.Key.Equals(expr))))
				{
					// Skip the notification source, if it's already added to some child
					if (!notifyProp.DependentNotifySources
						.SelectTree(p => p.Properties.SelectMany(p2 => p2.DependentNotifySources))
						.Any(d => d.Index == notifySource2.Index))
					{
						var notifPropData2Clone = notifySource2.Clone();
						notifyProp.DependentNotifySources.Add(notifPropData2Clone);
					}

					// The bindings are set in the "child" UpdateXX_XX method.
					foreach (var b in notifySource2.Properties.SelectMany(p => p.Bindings))
					{
						notifyProp.SetBindings.Remove(b);
					}
				}
			}
		}

		// Create Update methods for notify sources and properties
		foreach (var notifySource in notifySources)
		{
			// If the notify source has more than one property, the update method is needed
			// to update all properties for empty property name
			if (notifySource.ManyINotifyPropertyChangedProperties)
			{
				var bindings = notifySource.INotifyPropChangedProperties.SelectMany(_ => _.Bindings).Distinct().ToList();
				notifySource.UpdateMethod = CreateUpdateMethod(bindings, null, notifySource, notifySource.SourceExpression);
			}

			foreach (var prop in notifySource.Properties)
			{
				prop.UpdateMethod = CreateUpdateMethod(prop.SetBindings, prop.DependentNotifySources, null, notifySource.Expression);
			}
		}

		// Create the main Update method
		var binds1 = binds
			.Where(b => b.Property.TargetEvent == null && b.Mode != BindingMode.OneWayToSource)
			.ToList();
		var updateMethod = CreateUpdateMethod(binds1, notifySources, null, null);

		//*** Create data for two-way bindings

		var twoWayBinds = binds.Where(b => b.Mode is BindingMode.TwoWay or BindingMode.OneWayToSource);

		// two-way bindings for which UpdateSourceEventNames are explicitely set
		var twoWayEventHandlers1 = twoWayBinds
			.Where(b => b.UpdateSourceEvents.Count > 0)
			.SelectMany(b => b.UpdateSourceEvents.Select(e => (bind: b, evnt: e)))
			.GroupBy(e => (e.bind, e.evnt.Signature))
			.Select(g => new TwoWayBinding
			{
				TargetChangedEvents = g.Select(_ => _.evnt).Distinct().ToList(),
				Bindings = g.Select(_ => _.bind).Distinct().ToList(),
			});

		// two-way bindings for dependency properties
		var twoWayEventHandlers2 = twoWayBinds
			.Where(b => b.UpdateSourceEvents.Count == 0 && b.DependencyProperty != null)
			.GroupBy(b => (b.Property.Object, b.DependencyProperty))
			.Select(g => new TwoWayBinding
			{
				Bindings = g.ToList(),
			});

		// two-way bindings for objects implementing INotifyPropertyChanged
		var twoWayEventHandlers3 = twoWayBinds
			.Where(b => b.UpdateSourceEvents.Count == 0 &&
						b.DependencyProperty == null &&
						iNotifyPropertyChangedType.IsAssignableFrom(b.Property.Object.Type))
			.GroupBy(b => b.Property.Object)
			.Select(g => new TwoWayBinding
			{
				TargetChangedEvents = [iNotifyPropertyChangedType.Events[0]],
				Bindings = g.ToList(),
			});

		var twoWayEventHandlers = twoWayEventHandlers1.Concat(twoWayEventHandlers2).Concat(twoWayEventHandlers3).ToList();
		for (int i = 0; i < twoWayEventHandlers.Count; i++)
		{
			twoWayEventHandlers[i].Index = i;
		}

		return new BindingsClass
		{
			DataType = dataType,
			TargetType = targetType,
			Bindings = binds,
			NotifySources = notifySources,
			TwoWayEvents = twoWayEventHandlers,
			UpdateMethod = updateMethod,
		};

		static Expression getSourceExpr(Expression expr)
		{
			if (expr is ParenExpression pe)
			{
				return getSourceExpr(pe.Expression);
			}
			else if (expr is CastExpression ce)
			{
				return getSourceExpr(ce.Expression);
			}
			return expr;
		}
	}

	public static List<NotifySource> GetNotifySources(IList<Bind> binds, TypeInfo iNotifyPropertyChangedType, TypeInfo iNotifyCollectionChangedType, TypeInfo? dependencyObjectType)
	{
		var notifySources = binds
			.Where(b => b.Property.TargetEvent == null &&
						b.BindExpression != null &&
						b.Mode is not (BindingMode.OneTime or BindingMode.OneWayToSource))
			.SelectMany(b => b.BindExpression!
							 .EnumerateTree()
							 .OfType<INotifiableExpression>()
							 .Select(e => (bind: b, expr: e, notif: checkPropertyNotifiable(e, out var isDependencyProp, out var isCollectionChanged), isDependencyProp, isCollectionChanged)))
			.Where(e => e.notif != false)
			.GroupBy(e => e.expr.Expression.Key)
			.OrderBy(g => g.Key)
			.Select((g, i) =>
			{
				var expr1 = g.First().expr.Expression;
				var d = new NotifySource
				{
					Expression = expr1,
					SourceExpression = expr1,
					IsINotifyPropertyChanged = iNotifyPropertyChangedType.IsAssignableFrom(expr1.Type),
					Index = i,
				};
				d.Properties = g
					.GroupBy(e => getMemberName(e.expr, e.isCollectionChanged))
					.Select(g2 =>
					{
						var (_, expr2, _, isDependencyProp, isCollectionChanged) = g2.First();
						var bindings = g2.Select(e => e.bind).Distinct().ToList();

						string propertyCodeName = g2.Key;
						var propertyNames = new List<string> { propertyCodeName };
						if (expr2 is ElementAccessExpression)
						{
							propertyNames.Add("Items[]");
						}

						return new NotifyProperty
						{
							Parent = d,
							Member = expr2.Member,
							PropertyCodeName = propertyCodeName,
							PropertyNames = propertyNames,
							IsDependencyProp = isDependencyProp,
							IsCollectionChangedElementAccess = isCollectionChanged,
							Expression = (Expression)expr2,
							SourceExpression = (Expression)expr2,
							Bindings = new ReadOnlyCollection<Bind>(bindings),
							SetBindings = bindings.ToList(), // Make copy
						};
					})
					.ToList();
				return d;

				static string getMemberName(INotifiableExpression expression, bool isCollectionChanged)
				{
					if (isCollectionChanged)
					{
						var expr = (ElementAccessExpression)expression;
						if (expr.Parameters.Length == 1 &&
							Expression.StripParenExpression(expr.Parameters[0]) is ConstantExpression ce)
						{
							return "Item" + ce.CSharpCode;
						}
					}
					return expression.Member?.Definition.Name ?? "Item";
				}
			})
			.ToList();

		return notifySources;

		bool? checkPropertyNotifiable(INotifiableExpression expr, out bool isDependencyProp, out bool isCollectionChanged)
		{
			isDependencyProp = false;
			isCollectionChanged = false;

			// Not notifiable if explicitly turned off with / operator
			if (expr.IsNotifiable == false)
			{
				return false;
			}

			// Check if type is notifiable
			var type = expr.Expression.Type;

			if (type.Reference.IsArray)
			{
				return false;
			}

			bool isDependencyType = dependencyObjectType?.IsAssignableFrom(type) == true;
			bool isNotifyPropertyChangedType = iNotifyPropertyChangedType.IsAssignableFrom(type);
			if (!isDependencyType && !isNotifyPropertyChangedType)
			{
				// Check if the type can be potentally notifiable
				if (!type!.Reference.IsInterface() && type.Definition?.IsSealed == true)
				{
					return false;
				}
			}

			if (expr is MemberExpression me)
			{
				// No notifications for static members
				// TODO maybe for NET 7 with abstract static interfaces
				if (me.Member.Definition.IsStatic())
				{
					return false;
				}

				// The \ operator overrides ReadOnlyAttribute and get-only properties
				if (expr.IsNotifiable == null)
				{
					// Check if ReadOnlyAttribute is set
					var attr = me.Member.Definition.CustomAttributes.FirstOrDefault(a => a.AttributeType.FullName == "System.ComponentModel.ReadOnlyAttribute");
					bool? readOnly = (bool?)attr?.ConstructorArguments[0].Value;
					if (readOnly == true)
					{
						return false;
					}

					// Check if the property is get-only
					else if (readOnly == null && me.Member is PropertyInfo pi && pi.IsReadOnly)
					{
						return false;
					}

					// Notifications for not properties (other members), must be explicitely enabled
					if (me.Member is not PropertyInfo)
					{
						return false;
					}

					// If the type is not notifiable and no \ operator is used
					if (!isNotifyPropertyChangedType && !isDependencyType)
					{
						return false;
					}
				}
				// If the type is not notifiable, but \ operator is used.
				else if (!isNotifyPropertyChangedType && !isDependencyType)
				{
					return null;
				}

				var dependencyPropertyName = me.Member.Definition.Name + "Property";
				isDependencyProp = isDependencyType && type.Fields.Cast<IMemberInfo>().Concat(type.Properties).Any(m => m.Definition.Name == dependencyPropertyName);

				// For dependency property check if there is the backing store field or property (WinCE/UWP).
				// It must be named <PropertyName>Property
				return isNotifyPropertyChangedType || isDependencyProp;
			}
			else if (expr is ElementAccessExpression ea && iNotifyCollectionChangedType.IsAssignableFrom(ea.Expression.Type))
			{
				isCollectionChanged = true;
				return true;
			}
			else
			{
				// Notifications for elment access are active only if explicitly enabled with \ operator
				if (expr.IsNotifiable == true)
				{
					return isNotifyPropertyChangedType ? true : null;
				}
			}
			return false;
		}
	}

	private static UpdateMethod CreateUpdateMethod(IList<Bind> bindings, List<NotifySource>? notifySources, NotifySource? notifySource, Expression? replacedExpression)
	{
		List<VariableExpression> parameters = [];

		VariableExpression? valueExpression = null;
		if (replacedExpression != null)
		{
			var type = ExpressionUtils.GetExpressionType(replacedExpression);
			valueExpression = new VariableExpression(type, "value");
			parameters.Add(valueExpression);
		}

		var notifySources1 = notifySources ?? [];

		//Get the notify sources, for which UpdateXX methods are generated,
		//ordered descending by number of bindings set in them.
		var notifySources2 = notifySources1
			.Where(s => s.ManyINotifyPropertyChangedProperties)
			.OrderByDescending(s => s.INotifyPropChangedProperties.SelectMany(p => p.Bindings).Distinct().Count())
			.ToList();

		// Get UpdateXX methods, which can be called from the main Update
		var updateNotifySources = new List<NotifySource>();
		while (notifySources2.Count > 0)
		{
			var s = notifySources2[0];
			updateNotifySources.Add(s);
			notifySources2.RemoveAt(0);

			// Remove also all child notify sources
			notifySources2 = notifySources2
				.Except(EnumerableExtensions.SelectTree(s, _ => _.Properties.SelectMany(_ => _.DependentNotifySources)), _ => _.Index)
				.ToList();
			notifySources1 = notifySources1
				.Except(EnumerableExtensions.SelectTree(s, _ => _.Properties.SelectMany(_ => _.DependentNotifySources)), _ => _.Index)
				.ToList();

			// Remove bindings set in this UpdateXX method
			s.Properties.SelectMany(_ => _.Bindings).ForEach(_ => bindings.Remove(_));
		}

		// Get UpdateXX_XX methods, which can be used in this Update
		var updateMethodNotifyProps = new List<NotifyProperty>();

		var notifySources3 = notifySource != null
			? notifySources1.Append(notifySource)
			: notifySources1.Except(updateNotifySources);

		var notifProps = notifySources3
			.SelectMany(d => d.Properties)
			.OrderByDescending(p => p.Bindings.Count)
			.ThenByDescending(p => p.DependentNotifySources.SelectTree(p2 => p2.Properties.SelectMany(p3 => p3.DependentNotifySources)).Count())
			.ToList();

		while (notifProps.Count > 0)
		{
			var prop = notifProps[0];
			if (prop.Bindings.Any(b => updateNotifySources.SelectMany(s => s.Properties).SelectMany(p => p.Bindings).Contains(b)))
			{
				notifProps.RemoveAt(0);
			}
			else
			{
				updateMethodNotifyProps.Add(prop);
				prop.Bindings.ForEach(b => bindings.Remove(b));
				notifProps = notifProps.Where(p => !p.Bindings.Intersect(prop.Bindings).Any()).ToList();
				notifySources1 = notifySources1
					.Except(prop.DependentNotifySources.SelectTree(p => p.Properties.SelectMany(p2 => p2.DependentNotifySources)), f => f.Index)
					.ToList();
				foreach (var ns in prop.DependentNotifySources.SelectTree(p2 => p2.Properties.SelectMany(p3 => p3.DependentNotifySources)))
				{
					var index = updateNotifySources.IndexOf(s => s.Index == ns.Index);
					if (index != -1)
					{
						updateNotifySources.RemoveAt(index);
					}
				}
			}
		}

		// Get notify sources in the bindings set directly in this Update method,
		// for which event handlers must be set.
		var notifySources4 = notifySources ?? [notifySource!];
		foreach (var expr in bindings
			.SelectMany(b => b.BindExpression!.EnumerateTree())
			.OfType<INotifiableExpression>())
		{
			var expr2 = expr.Expression;
			var notifySource2 = notifySources4.SelectTree(_ => _.Properties.SelectMany(_ => _.DependentNotifySources)).FirstOrDefault(s => s.SourceExpression == expr2);
			if (notifySource2 != null && notifySource2 != notifySource && !notifySources1.Any(s => s.Index == notifySource2.Index))
			{
				notifySources1.Add(notifySource2.Clone());
			}
		}

		// Replace and group expressions of
		// - Bindings, set direct in this Update method
		// - UpdateXX methods
		// - UpdateXX_XX methods
		// - SetPropertyHandler methods

		var props1 = bindings
			.Select(b => new PropertySetData(b.Property, replace(b.BindExpression!)))
			.ToList();

		var props2 = updateNotifySources
			.Select(g => new PropertySetData(g.Properties[0].Bindings[0].Property, replace(g.Expression)))
			.ToList();

		var props3 = updateMethodNotifyProps
			.Select(p => new PropertySetData(p.Bindings[0].Property, replace(p.Parent.Expression)))
			.ToList();

		var props4 = notifySources1
			.Select(g => new PropertySetData(g.Properties[0].Bindings[0].Property, replace(g.Expression)))
			.ToList();

		var props5 = props1.Concat(props2).Concat(props3).Concat(props4).ToList();

		var localVars2 = ExpressionUtils.GroupExpressions(props5);

		for (int i = 0; i < updateNotifySources.Count; i++)
		{
			updateNotifySources[i].SourceExpression = props2[i].Expression;
		}

		for (int i = 0; i < props3.Count; i++)
		{
			updateMethodNotifyProps[i].SourceExpression = props3[i].Expression;
		}

		for (int i = 0; i < props4.Count; i++)
		{
			notifySources1[i].SourceExpression = props4[i].Expression;
		}

		var updateExpressions = new ExpressionGroup
		{
			LocalVariables = localVars2,
			SetExpressions = props1
		};

		return new UpdateMethod
		{
			Parameters = parameters,
			UpdateNotifySources = updateNotifySources,
			UpdateNotifyProperties = updateMethodNotifyProps,
			Expressions = updateExpressions,
			SetEventHandlers = notifySources1,
		};

		Expression replace(Expression expr)
		{
			if (replacedExpression != null)
			{
				expr = expr.CloneReplace(replacedExpression, valueExpression!);
			}
			return expr;
		}
	}

	private static class Res
	{
		public const string SyntaxError = "Syntax error.";
		public const string MissingExpression = "Missing expression.";
		public const string NoDataType = "DataType is unknown. It must be specified when using x:Bind in a DataTemplate.";
	}
}

public class BindingsClass
{
	public required TypeInfo? TargetType { get; init; }
	public required TypeInfo DataType { get; init; }
	public required IList<Bind> Bindings { get; init; }
	public required List<NotifySource> NotifySources { get; init; }
	public required List<TwoWayBinding> TwoWayEvents { get; init; }
	public required UpdateMethod UpdateMethod { get; init; }
};

public class NotifySource
{
	public required Expression Expression { get; init; }
	public required Expression SourceExpression { get; set; }
	public List<NotifyProperty> Properties { get; set; } = null!;
	public UpdateMethod? UpdateMethod { get; set; }
	public bool IsINotifyPropertyChanged { get; init; }
	public int Index { get; init; }

	public bool AnyDependencyProperty => Properties.Any(p => p.IsDependencyProp);

	public bool AnyCollectionChangedElementAccess => Properties.Any(p => p.IsCollectionChangedElementAccess);

	public bool AnyINotifyPropertyChangedProperty => Properties
		.Any(p => !p.IsDependencyProp && !p.IsCollectionChangedElementAccess);

	public bool ManyINotifyPropertyChangedProperties => INotifyPropChangedProperties.Take(2).Count() > 1;

	public IEnumerable<NotifyProperty> INotifyPropChangedProperties => Properties
		.Where(p => !p.IsDependencyProp && !p.IsCollectionChangedElementAccess);

	public NotifySource Clone()
	{
		return (NotifySource)MemberwiseClone();
	}
};

public class NotifyProperty
{
	public required NotifySource Parent { get; init; }
	public required IMemberInfo? Member { get; init; }
	public required bool IsDependencyProp { get; init; }
	public required bool IsCollectionChangedElementAccess { get; init; }
	public required IList<string> PropertyNames { get; init; }
	public required string PropertyCodeName { get; init; }
	public required Expression Expression { get; init; }
	public required Expression SourceExpression { get; set; }
	public required ReadOnlyCollection<Bind> Bindings { get; init; }
	public required List<Bind> SetBindings { get; init; }
	public List<NotifySource> DependentNotifySources { get; } = [];
	public UpdateMethod? UpdateMethod { get; set; }
};

public class UpdateMethod
{
	public required List<VariableExpression> Parameters { get; init; }
	public required ExpressionGroup Expressions { get; init; }
	public required List<NotifySource> UpdateNotifySources { get; init; }
	public required List<NotifyProperty> UpdateNotifyProperties { get; init; }
	public required List<NotifySource> SetEventHandlers { get; init; }
}

public class TwoWayBinding
{
	public required List<Bind> Bindings { get; init; }
	public List<EventInfo>? TargetChangedEvents { get; init; }
	public int Index { get; set; }
};

public class Bind
{
	public Expression? Path { get; init; }
	public Expression? BindBack { get; init; }
	public BindingMode Mode { get; init; }
	public bool IsItemsSource { get; init; }
	public Expression? Converter { get; init; }
	public Expression? ConverterParameter { get; init; }
	public Expression? FallbackValue { get; init; }
	public TypeInfo? DataType { get; init; }
	public bool DataTypeSet { get; init; }
	public required List<EventInfo> UpdateSourceEvents { get; init; }

	public required TypeInfo SourceType { get; init; }
	public required XamlObjectProperty Property { get; init; }

	// The final source expression,
	// including Converter, TargetNull, FallbackValue, StringFormat
	public Expression? BindExpression { get; set; }
	public Expression? AsyncBindExpression { get; set; }
	public Expression? BindBackExpression { get; init; }

	public IMemberInfo? DependencyProperty { get; set; }
	public int Index { get; set; }
}

public enum BindingMode
{
	OneTime = 0x00,
	OneWay = 0x01,
	OneWayToSource = 0x10,
	TwoWay = 0x11,
}
